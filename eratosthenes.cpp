/*소수(prime number) 판별 알고리즘이다. 2 3 5 7 11 ... 
어떤 수로도 나뉘어지지 않아야되기때문에 그 수 x를 i(2~x)로 나눠보면된다
그러나 이 방법은 O(N)의 복잡도를 갖는다. 모든 수를 다 체크했기때문이다.
O(N^(1/2))로 계산하려면 8=2*4=4*2이기때문에 제곱근까지만 약수의 여부를 검증하면된다.
int end = (int) sqrt(x)로 두고 x의 소수를 구하기위해서는 i(2~end)까지 체크
대량의 소수를 한꺼번에 판별하고자 하는게 에라토스의 체이다.
1. 이차원배열을 생성하여 값을 초기화한다.
2. 2부터 시작해서 특정 숫자의 배수에 해당하는 숫자들을 모두 지운다.(자신은안지움)
3. 3의 배수도 지운다 (자신은 안지우고 이미 지운경우는 건너뛴다.)
4. 남아있는 숫자들을 출력한다.*/

#include <stdio.h>

int number = 100000;
int a[100001];

void primeNumberSieve() {
	for (int i = 2; i <= number; i++) {
		a[i] = i; //배열을 다 초기화해준다.
	}
	for (int i = 2; i <= number; i++) {
		if (a[i] == 0) continue; //이미 방문했던곳은 방문하지않는다.
		for (int j = i+i; j <= number; j += i) { //배수
			a[j] = 0; //방문처리
		}
	}
	for (int i = 2; i <= number; i++) {
		if (a[i] != 0) //0으로 변하지 않은 남은 소수부분 출력
			printf("%d ", a[i]);
	}
}
int main() {
	primeNumberSieve();
}
